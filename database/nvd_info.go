package database

import (
	"fmt"
	"log"

	"nvdbase/chat"
	"nvdbase/cve"
)

func GetPkgInfoFromVuln(
	vuln cve.Vulnerability,
	apiKey, modelName string,
) (cve.PackageInfoNVD, error) {
	vulnDataStr := fmt.Sprintf("%s\n", vuln)

	systemMessage := &chat.Message{Role: "system", Content: chat.SystemMessageStr}
	userMessage := &chat.Message{Role: "user", Content: vulnDataStr}
	chatReq := &chat.ChatRequest{
		Messages: []chat.Message{*systemMessage, *userMessage},
		Model:    modelName,
	}

	completion, err := chat.GetChatCompletion(chatReq, apiKey)
	if err != nil {
		log.Println("Got err: ", err.Error(), " from chat completion. returning")
		return cve.PackageInfoNVD{}, err
	}

	var pkgInfo cve.PackageInfoNVD
	err = cve.Decode([]byte(completion.Choices[0].Message.Content), &pkgInfo)
	if err != nil {
		log.Println("Error decoding into package information")
		return cve.PackageInfoNVD{}, err
	}

	fmt.Printf("got package info: %+v\n", pkgInfo)
	return pkgInfo, nil
}

func GetPkgInfo(
	vulnerabilities []cve.Vulnerability,
	apiKey, modelName string,
) <-chan cve.PackageInfoNVD {
	pkgInfoCh := make(chan cve.PackageInfoNVD)
	go func() {
		defer close(pkgInfoCh)
		for _, vuln := range vulnerabilities {
			pkgInfo, err := GetPkgInfoFromVuln(vuln, apiKey, modelName)
			if err != nil {
				log.Printf(
					"Error getting package information from vulnerability node: %s\n",
					err.Error(),
				)
				continue
			}
			pkgInfoCh <- pkgInfo
		}
	}()

	return pkgInfoCh
}
